## Reverse Engineering , Analysis 

### Driver Entry 
- Driver Entry prettified :
```C
NTSTATUS __fastcall Real_Driver_Entry(PDRIVER_OBJECT DriverObject)
{
  PDRIVER_OBJECT v1; // rdi
  NTSTATUS result; // eax
  NTSTATUS v3; // ebx
  char *v4; // rbx
  PDEVICE_OBJECT DeviceObject; // [rsp+40h] [rbp-98h]
  UNICODE_STRING DeviceName_1; // [rsp+48h] [rbp-90h]
  UNICODE_STRING SymbolicLinkName; // [rsp+58h] [rbp-80h]
  WCHAR DeviceName; // [rsp+68h] [rbp-70h]
  WCHAR SymLink; // [rsp+90h] [rbp-48h]

  v1 = DriverObject;
  memmove(&DeviceName, L"\\Device\\DBUtil_2_3", 0x26ui64);
  memmove(&SymLink, L"\\DosDevices\\DBUtil_2_3", 0x2Eui64);
  RtlInitUnicodeString(&DeviceName_1, &DeviceName);
  RtlInitUnicodeString(&SymbolicLinkName, &SymLink);
  result = IoCreateDevice(v1, 0xA0u, &DeviceName_1, 0x9B0Cu, 0, 1u, &DeviceObject);
  if ( !result )
  {
    v3 = IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName_1);
    if ( v3 )
    {
      IoDeleteDevice(DeviceObject);
      result = v3;
    }
    else
    {
      v1->MajorFunction[16] = (PDRIVER_DISPATCH)Possible_DispatchDeviceControl0;// IRP_MJ_SHUTDOWN
      v1->MajorFunction[0] = (PDRIVER_DISPATCH)Possible_DispatchDeviceControl0;// IRP_MJ_CREATE
      v1->MajorFunction[2] = (PDRIVER_DISPATCH)Possible_DispatchDeviceControl0;// IRP_MJ_CLOSE
      v1->MajorFunction[14] = (PDRIVER_DISPATCH)Possible_DispatchDeviceControl0;// IRP_MJ_DEVICE_CONTROL
      v4 = (char *)DeviceObject->DeviceExtension;
      memset(DeviceObject->DeviceExtension, 0, 0xA0ui64);
      *((_QWORD *)v4 + 2) = 0i64;
      KeInitializeDpc((PRKDPC)(v4 + 24), (PKDEFERRED_ROUTINE)DeferredRoutine, v4);
      KeSetTargetProcessorDpc(v4 + 24, 0i64);
      KeSetImportanceDpc(v4 + 24, 2i64);
      result = 0;
    }
  }
  return result;
}
```
There is one Dispatch routine what will handle **CREATE , CLOSE , SHUTDOWN , DEVICE_CONTROL*** operations , this will be done by checking the type of the request on the packet :
```C
 v2 = Ir_packet->Tail.Overlay.CurrentStackLocation;
  userBuffer = *(_QWORD ***)(a1 + offsetof(DEVICE_OBJECT, DeviceExtension));
  v4 = 0;
  *((_DWORD *)userBuffer + 2) = 0;
  v5 = Ir_packet;
  if ( v2->MajorFunction != 14 )
    goto LABEL_61;
```
If The MajorFunction is not 14 (DeviceIoControl) the program flow will be switched to another branch , now let's see if it's equal to 14 

```C
 *userBuffer = &Ir_packet->AssociatedIrp.MasterIrp->Type;// IRP_MJ_DEVICE_CONTROL
  v6 = v2->Parameters.Create.Options;
  *((_DWORD *)userBuffer + 2) = v6;
  if ( v6 == v2->Parameters.Read.Length )
  {
    v7 = v2->Parameters.Read.ByteOffset.LowPart;
    if ( v7 <= 0x9B0C1F40 )
    {
      if ( v7 != 0x9B0C1F40 )
      {
        if ( v7 == 0x9B0C1EC0 )
        {
          v15 = sub_FFFFF8013E8051D4((__int64)userBuffer);
        }
        else
        {
          if ( v7 == 0x9B0C1EC4 )
          {
            v14 = 1;
          }
          else
          {
            if ( v7 != 0x9B0C1EC8 )
            {
              switch ( v7 )
              {
                case 0x9B0C1ECC:
                  if ( v6 != 24 )
                    goto LABEL_3;
                  v25 = (_QWORD *)**userBuffer;
                  v27 = (*userBuffer)[2];
                  v12 = userBuffer[2];
                  if ( !v12 || v12 == v25 )
                  {
                    MmFreeContiguousMemorySpecifyCache((*userBuffer)[1], (unsigned int)v27, 0i64);
                    LODWORD(v27) = 0;
                    v13 = *userBuffer;
                    *v13 = v25;
                    v13[1] = 0i64;
                    v13[2] = v27;
                    goto LABEL_61;
                  }
                  break;
                case 0x9B0C1F00:
                  if ( v6 != 72 )
                    goto LABEL_3;
                  memmove(&Dst, *userBuffer, 0x48ui64);
                  v11 = userBuffer[2];
                  if ( !v11 || v11 == Dst )
                  {
                    memmove(userBuffer + 11, &Dst, 0x48ui64);
                    DeferredRoutine(0i64, userBuffer, 0i64, 0i64);
                    memmove(&Dst, userBuffer + 11, 0x48ui64);
                    goto LABEL_23;
                  }
                  break;
                case 0x9B0C1F04:
                  if ( v6 != 72 )
                    goto LABEL_3;
                  memmove(&Dst, *userBuffer, 0x48ui64);
                  v10 = userBuffer[2];
                  if ( !v10 || v10 == Dst )
                  {
                    v29 = 0;
                    memmove(userBuffer + 11, &Dst, 0x48ui64);
                    KeInsertQueueDpc((PRKDPC)(userBuffer + 3), userBuffer, userBuffer);
LABEL_23:
                    v9 = (__int64 *)&Dst;
LABEL_18:
                    memmove(*userBuffer, v9, 0x48ui64);
                    goto LABEL_61;
                  }
                  break;
                default:
                  if ( v7 != 0x9B0C1F08 || v6 != 72 )
                    goto LABEL_3;
                  memmove(&Dst, *userBuffer, 0x48ui64);
                  v8 = userBuffer[2];
                  if ( v8 && v8 != Dst )
                    break;
                  v9 = (__int64 *)(userBuffer + 11);
                  goto LABEL_18;
              }
LABEL_16:                                       
              v4 = 0xC0000005;
              goto LABEL_62;
            }
            v14 = 0;
          }
          v15 = sub_FFFFF8013E805294(userBuffer, v14); // DANGER
        }
        goto LABEL_60;
      }
      v16 = 1;
      goto LABEL_59;
    }
    if ( v7 == 0x9B0C1F44 )
    {
      v16 = 0;
LABEL_59:
      v15 = sub_FFFFF8013E805100((__int64)userBuffer, v16);
```
- There is more IOCTL for another operations but this is enough for us , to locate the vulnerable piece.
- For IOCTL code = 0x9B0C1EC4 , Details : ***{FILE_ANY_ACCESS , METHOD_BUFFERED}*** a variable that works like a boolean is set (v14) to 1 , it's usage will be revealed later <br/>
- the corresponding function to this IOCTL is ***sub_FFFFF8013E805294*** :
```C
__int64 __fastcall sub_FFFFF8013E805294(__int64 **UserBuffer, char a2)
{
  __int64 **v2; // rbx
  unsigned int size; // ecx
  __int64 *v5; // r9
  __int64 *v6; // rax
  unsigned int v7; // eax
  void *v8; // rcx
  const void *v9; // rdx
  __int64 *v10; // rcx
  __int64 v11; // [rsp+20h] [rbp-28h]
  __int64 v12; // [rsp+28h] [rbp-20h]
  __int64 v13; // [rsp+30h] [rbp-18h]

  v2 = UserBuffer;
  size = *((_DWORD *)UserBuffer + 2);
  if ( size < 0x18 )
    return 0xC000000Di64;
  v5 = *v2;
  v11 = **v2;
  v12 = (*v2)[1];
  v13 = (*v2)[2];
  v6 = v2[2];
  if ( v6 && v6 != (__int64 *)v11 )
    return 0xC0000005i64;
  v7 = size - 24;
  v8 = (void *)(v12 + (unsigned int)v13);
  if ( a2 )
  {
    v9 = (const void *)(v12 + (unsigned int)v13);
    v8 = v5 + 3;
  }
  else
  {
    v9 = v5 + 3;
  }
  memmove(v8, v9, v7);
  v10 = *v2;
  *v10 = v11;
  v10[1] = v12;
  v10[2] = v13;
  return 0i64;
}
```
- What this code does is Check the length of the Buffer (must be > 0x18) , then the if , else statement where the v14 variable passed as a2 will work as a flag to chose a program flow . 
- after that we have a memmove , what is interesting is that the v8 (Destination) is an address and data that we can supply in our buffer (controlled content) , supplying an address and a data to write to that address will result in an aritrary write , what is more interesting is that if the variable a2 is set to 0 we have an arbitrary read , the corresponding IOCTL for that is ***0x9B0C1EC8***
- what we have is : 
  - Write-anywhere : ***0x9B0C1EC4***
  - Read-From-Anywhere primitives ***0x9B0C1EC8***
## Exploitation
- First we need to see how our buffer need to be sent , we generate a payload to see the offsets in the IO_STACK , this can be done with a tool called IOCTLpus
- The Driver is loaded at ***0xfffff8024a280000***
```fffff802`4a280000 fffff802`4a287000   dbutil_2_3   (deferred) ``` 
we place a breakpoint at the CMP of the IOCTL responsible for the write in windbg : ***FFFFF8024A2811E5*** , we set another one just before the memmove to see what offsets correspond to the arguments passed to ***memmove***








Let's try to make the Blue screen pop , what we can do is write at some address that doesn't exist to generate an exception 
